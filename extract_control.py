#!/usr/bin/env python

import re
import textwrap
import argparse
import shelve
import sys


class ParseSetupIni(object):

    def __init__(self, filename='setup.ini', shelf='setup.shelf', cached=False):
        if cached:
            db = shelve.open(shelf)
            self.filename = db['filename']
            self.arch = db['arch']
            self.maintainer = db['maintainer']
            self.entries = db['entries']
            self.packages = db['packages']
        else:
            self.filename = filename
            myfile = open(filename, 'rb')
            self.contents = myfile.read()
            self.contents = self.sanitize_contents(self.contents)
            self.arch = self.get_architecture(self.contents)
            self.maintainer = 'nomaintainer@no-email.com'
            self.listings = self.split_listings(self.contents)
            self.listings = [self.sanitize_listing(x) for x in self.listings]

            dict_list = [self.read_listing(x) for x in self.listings]
            self.packages = [x['name'] for x in dict_list]
            self.entries = {x['name']: x for x in dict_list}

            db = shelve.open(shelf, 'n')
            db['packages'] = self.packages
            db['filename'] = self.filename
            db['arch'] = self.arch
            db['maintainer'] = self.maintainer
            db['entries'] = self.entries
            db.close()

    def sanitize_contents(self, contents):
        """ Sanitizes the contents of a Cygwin 'setup.ini' field. All
        carriage returns are stripped out, as well as all comments. Tabs
        are replaced with single spaces, and multiple newlines are
        de-duplicated. """

        contents = '\n\n' + contents
        contents = contents.replace('\r', '')
        contents = contents.replace('\t', ' ')
        contents = re.sub("\n[ \t]*[#].*(?=\n)", "", contents)
        contents = re.sub("[ ]+", " ", contents)

        contents = contents.split('\n')
        contents = '\n'.join([x.strip() for x in contents])

        contents = re.sub("\n\n[\n]+", "\n\n", contents)
        contents = contents.strip() + '\n\n'

        return contents

    def test(self):
        print "Listing count: ", len(self.entries)
        print self.entries[-1]

    def get_architecture(self, contents):
        """ Creates an architecture string to use in the output 'control'
        files. The string is generated by combining the original Cygwin
        setup.ini's 'release' and 'arch' fields. """

        if contents.find('@') != -1:
            contents = contents[0:contents.find('@')]
        contents = contents.strip()

        keys = {}
        for line in contents.split('\n'):
            key, value = line.split(': ')
            keys[key] = value

        return keys['arch']

    def split_listings(self, contents):
        """ Splits the contents of a Cygwin setup.ini file into separate
        listings for each package described in the file. """
        contents = contents + '\n@'
        regex = '\n[@].+?(?=\n[@])'
        listings = re.findall(regex, contents, flags=re.DOTALL)
        listings = [x.strip() for x in listings]

        return listings

    def sanitize_listing(self, listing, add_current=False, strip_prev=True,
                         strip_test=True):
        """ Sanitizes a listing extracted from a Cygwin setup.ini file.
        This routine turns quoted strings into unquoted lines. Multi-line
        strings are joined if necessary.

        Tabs are transformed into spaces, and multiple space characters are
        replaced by a single space.

        Optionally, this routine can also add the '[current]' tag to a data
        field, or it can delete the [prev] and/or [test] tags. """

        listing = listing + '\n'
        if add_current:
            name_string = re.findall(r'\A@.+?\n', listing)[0]
            replacement = name_string + '[current]\n'
            listing = re.sub(r'\A@.+?\n', replacement, listing)

        match = re.search(
            '\n[a-zA-Z]+?[:][ \t]*["].*?["]',
            listing,
            flags=re.DOTALL)

        while match is not None:
            string = listing[match.start():match.end()]
            string = string.replace('"', '')
            string = string.strip()
            string = '\n' + string.replace('\n', ' ')
            listing = listing[0:match.start()] + string + listing[match.end():]
            match = re.search(
                '\n[a-zA-Z]+?[:][ \t]*["].*?["]',
                listing,
                flags=re.DOTALL)

        listing = re.sub('[ \t]+', ' ', listing).strip()

        if strip_test and listing.find('\n[test]') != -1:
            listing = listing[0:listing.find('\n[test]')] + '\n'

        if strip_prev and listing.find('\n[prev]') != -1:
            listing = listing[0:listing.find('\n[prev]')] + '\n'

        return listing

    def read_listing(self, listing):
        """ Turns a sanitized listing from a Cygwin setup.ini into a dict
        of all relevant fields."""

        result = {}

        name = re.findall(r'\A@.+?\n', listing)[0]
        name = name.strip()
        if name[0] == '@':
            name = name[1:]
        result['name'] = name.strip().lower()

        fields = ['sdesc', 'ldesc', 'category', 'requires']
        fields += ['version', 'install', 'source']

        for field in fields:
            listing = re.sub('\n%s[ \t][:][ \t]*' % field, '\n%s[:] ', listing)
            regex = '(?<=\n%s[:] ).+\n' % field
            if re.findall(regex, listing) == []:
                result[field] = ''
            else:
                value = re.findall(regex, listing)[0].strip()
                result[field] = value

        return result

    def create_control(self, listing_dict, priority='optional'):
        """ Reads in a dictionary generated from a setup.ini listing, and
        generates the text contents of a 'control' file as found in a
        .ipk/.opk/.deb file. """

        version = listing_dict['version']
        section = listing_dict['category']

        package = listing_dict['name'].lower()
        package = re.sub('[^a-z0-9.+-]', '-', package)

        description = listing_dict['sdesc'] + '\n '
        description += '\n '.join(textwrap.wrap(listing_dict['ldesc'], 60))
        description = description.strip()

        depends = listing_dict['requires']
        depends = ','.join(depends.split())

        control = []

        control.append(['Package', package])
        control.append(['Version', version])
        control.append(['Section', section])
        control.append(['Priority', priority])
        control.append(['Architecture', self.arch])
        control.append(['Maintainer', self.maintainer])
        control.append(['Depends', depends])
        control.append(['Description', description])

        result = ''
        for entry in control:
            result = result + "%s: %s\n" % (entry[0], entry[1])

        return result

    def create_source(self, listing_dict):
        """ Reads in a dictionary generated from a setup.ini listing, and
        generates the text contents of a 'source' file, which is not standard
        package file, but will allow for easier retrieval from a remote
        server. """

        source = listing_dict['source']

        if source != '':
            filename, size, checksum = source.strip().split()
        else:
            filename, size, checksum = "NONE", "NONE", "NONE"
        lines = []

        lines.append(['File', filename])
        lines.append(['Size', size])
        lines.append(['Checksum', checksum])

        result = ''
        for entry in lines:
            result = result + "%s: %s\n" % (entry[0], entry[1])

        return result

    def create_install(self, listing_dict):
        """ Reads in a dictionary generated from a setup.ini listing, and
        generates the text contents of an 'install' file, which is not standard
        package file, but will allow for easier retrieval from a remote
        server. """

        install = listing_dict['install']
        filename, size, checksum = install.strip().split()
        lines = []

        lines.append(['File', filename])
        lines.append(['Size', size])
        lines.append(['Checksum', checksum])

        result = ''
        for entry in lines:
            result = result + "%s: %s\n" % (entry[0], entry[1])

        return result


DESCRIPTION = """Cygwin INI parser. Reads a Cygwin setup.ini file and splits
up all of the entries into Python dicts. Writes one of:
   - List of entries in Setup.ini
   - Control file for packaging as a .opk
   - Install file for scripted download of binary files
   - Source file for scripted download of source files
to standard out.

Optionally, this utility can reload pre-parsed results from a shelf file
that it creates while parsing setup.ini.
"""

EPILOG = """Copyright 2015. Written by Nicholas Clark."""


def create_parser():
    parser = argparse.ArgumentParser()
    parser.formatter_class = argparse.RawDescriptionHelpFormatter
    parser.description = DESCRIPTION
    parser.epilog = EPILOG
    parser.add_argument('-r', '--reload', default=False, action='store_true',
                        help='Reload an already-parsed database from the' +
                        ' shelf file)')

    parser.add_argument('--shelf', default='setup.shelf',
                        help='Shelf file to use for storing parsed-results' +
                        " (default: setup.shelf)")

    parser.add_argument('--ini', default='setup.ini',
                        help="Ini file to parse, if 'reload' is false." +
                        " (default: setup.ini)")

    group = parser.add_mutually_exclusive_group()
    group.add_argument('-e', '--entries', default=False, action='store_true',
                       help='Generates a list of all packages.')

    group.add_argument('-c', '--control', default='',
                       help="Generates a 'control' file for the target" +
                       " package.")

    group.add_argument('-s', '--source', default='',
                       help="Generates a 'source' file for the target" +
                       " package.")

    group.add_argument('-i', '--install', default='',
                       help="Generates an 'install' file for the target" +
                       " package.")

    return parser


def parse_args(parser):
    args = parser.parse_args()
    return args


def main():
    parser = create_parser()
    args = parse_args(parser)

    if args.reload:
        mySetup = ParseSetupIni(filename='', shelf=args.shelf, cached=True)
    else:
        mySetup = ParseSetupIni(filename=args.ini, shelf=args.shelf)

    try:
        if args.entries:
            for package in mySetup.packages:
                sys.stdout.write(package + '\n')

        if args.control:
            entry = mySetup.entries[args.control]
            sys.stdout.write(mySetup.create_control(entry))

        if args.source:
            entry = mySetup.entries[args.source]
            sys.stdout.write(mySetup.create_source(entry))

        if args.install:
            entry = mySetup.entries[args.install]
            sys.stdout.write(mySetup.create_install(entry))

    except IOError:
        sys.exit(0)

    return

if __name__ == '__main__':
    main()
