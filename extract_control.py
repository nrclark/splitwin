#!/usr/bin/env python

import re
import textwrap


class setup_file(object):

    def __init__(self, filename='setup.ini'):
        self.filename = filename
        self.file = open(filename, 'rb')
        self.contents = self.file.read()
        self.contents = self.sanitize_contents(self.contents)
        self.arch = self.get_architecture(self.contents)
        self.maintainer = 'nomaintainer@no-email.com'

    def sanitize_contents(self, contents):
        """ Sanitizes the contents of a Cygwin 'setup.ini' field. All
        carriage returns are stripped out, as well as all comments. Tabs
        are replaced with single spaces, and multiple newlines are
        de-duplicated. """

        contents = '\n\n' + contents
        contents = contents.replace('\r', '')
        contents = contents.replace('\t', ' ')
        contents = re.sub("\n[ \t]*[#].*(?=\n)", "", contents)
        contents = re.sub("[ ]+", " ", contents)

        contents = contents.split('\n')
        contents = '\n'.join([x.strip() for x in contents])

        contents = re.sub("\n\n[\n]+", "\n\n", contents)
        contents = contents.strip() + '\n\n'

        return contents

    def test(self):
        print "Total @ symbols:", self.contents.count('@')
        print "Fresh @ symbols:", len(re.findall("\n[ \t\n]*[@]", self.contents))
        print "Listing count: ", len(self.split_listings(self.contents))
        print self.split_listings(self.contents)[-1]

    def get_architecture(self, contents):
        """ Creates an architecture string to use in the output 'control'
        files. The string is generated by combining the original Cygwin
        setup.ini's 'release' and 'arch' fields. """

        if contents.find('@') != -1:
            contents = contents[0:contents.find('@')]
        contents = contents.strip()

        keys = {}
        for line in contents.split('\n'):
            key, value = line.split(': ')
            keys[key] = value

        return keys['release'] + "-" + keys['arch']

    def split_listings(self, contents):
        """ Splits the contents of a Cygwin setup.ini file into separate
        listings for each package described in the file. """
        contents = contents + '\n@'
        regex = '\n[@].+?(?=\n[@])'
        listings = re.findall(regex, contents, flags=re.DOTALL)
        listings = [x.strip() for x in listings]

        return listings

    def sanitize_listing(self, listing, add_current=False, strip_prev=True):
        """ Sanitizes a listing extracted from a Cygwin setup.ini file.
        This routine turns quoted strings into unquoted lines. Multi-line
        strings are joined if necessary.

        Tabs are transformed into spaces, and multiple space characters are
        replaced by a single space.

        Optionally, this routine can also add the '[current]' tag to a data
        field, or it can delete the [prev] tags. """

        listing = listing + '\n'
        if add_current:
            name_string = re.findall(r'\A@.+?\n', listing)[0]
            replacement = name_string + '[current]\n'
            listing = re.sub(r'\A@.+?\n', replacement, listing)

        match = re.search(
            '\n[a-zA-Z]+?[:][ \t]*["].*?["]',
            listing,
            flags=re.DOTALL)

        while match is not None:
            string = listing[match.start():match.end()]
            string = string.replace('"', '')
            string = string.strip()
            string = '\n' + string.replace('\n', ' ')
            listing = listing[0:match.start()] + string + listing[match.end():]
            match = re.search(
                '\n[a-zA-Z]+?[:][ \t]*["].*?["]',
                listing,
                flags=re.DOTALL)

        listing = re.sub('[ \t]+', ' ', listing).strip()

        if strip_prev and listing.find('\n[prev]') != -1:
            listing = listing[0:listing.find('\n[prev]')] + '\n'

        return listing

    def read_listing(self, listing):
        """ Turns a sanitized listing from a Cygwin setup.ini into a dict
        of all relevant fields."""

        result = {}

        name = re.findall(r'\A@.+?\n', listing)[0]
        name = name.strip()
        if name[0] == '@':
            name = name[1:]
        result['name'] = name.strip().lower()

        fields = ['sdesc', 'ldesc', 'category', 'requires']
        fields += ['version', 'install', 'source']

        for field in fields:
            listing = re.sub('\n%s[ \t][:][ \t]*' % field, '\n%s[:] ', listing)
            regex = '(?<=\n%s[:] ).+\n' % field
            if re.findall(regex, listing) == []:
                result[field] = ''
            else:
                value = re.findall(regex, listing)[0].strip()
                result[field] = value

        return result

    def create_control(self, listing_dict, priority='optional'):
        """ Reads in a dictionary generated from a setup.ini listing, and
        generates the text contents of a 'control' file as found in a
        .ipk/.opk/.deb file. """

        version = listing_dict['version']
        section = listing_dict['category']

        package = listing_dict['name'].lower()
        package = re.sub('[^a-z0-9.+-]', '-', package)

        description = listing_dict['sdesc'] + '\n '
        description += '\n '.join(textwrap.wrap(listing_dict['ldesc'], 60))
        description = description.strip()

        depends = listing_dict['requires']
        depends = ','.join(depends.split())

        control = []

        control.append(['Package', package])
        control.append(['Version', version])
        control.append(['Section', section])
        control.append(['Priority', priority])
        control.append(['Architecture', self.arch])
        control.append(['Maintainer', self.maintainer])
        control.append(['Depends', depends])
        control.append(['Description', description])

        result = ''
        for entry in control:
            result = result + "%s: %s\n" % (entry[0], entry[1])

        return result

    def create_source(self, listing_dict):
        """ Reads in a dictionary generated from a setup.ini listing, and
        generates the text contents of a 'source' file, which is not standard
        package file, but will allow for easier retrieval from a remote
        server. """

        source = listing_dict['source']
        filename, size, checksum = source.strip().split()
        lines = []

        lines.append(['File', filename])
        lines.append(['Size', size])
        lines.append(['Checksum', checksum])

        result = ''
        for entry in lines:
            result = result + "%s: %s\n" % (entry[0], entry[1])

        return result

    def create_install(self, listing_dict):
        """ Reads in a dictionary generated from a setup.ini listing, and
        generates the text contents of an 'install' file, which is not standard
        package file, but will allow for easier retrieval from a remote
        server. """

        install = listing_dict['install']
        filename, size, checksum = install.strip().split()
        lines = []

        lines.append(['File', filename])
        lines.append(['Size', size])
        lines.append(['Checksum', checksum])

        result = ''
        for entry in lines:
            result = result + "%s: %s\n" % (entry[0], entry[1])

        return result


def main():
    myfile = setup_file()
    myfile.test()
    listings = myfile.split_listings(myfile.contents)
    listings = listings[0:1]

    listings = [myfile.sanitize_listing(x) for x in listings]
    for x in listings:
        print x
        print "----------------"
        print myfile.read_listing(x)
        print "----------------"
        print myfile.create_control(myfile.read_listing(x))
        print "----------------"
        print myfile.create_source(myfile.read_listing(x))
        print "----------------"
        print myfile.create_install(myfile.read_listing(x))

if __name__ == '__main__':
    main()
